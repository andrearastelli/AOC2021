from itertools import pairwise, chain, tee
from collections import Counter
from functools import lru_cache
from pathlib import Path
from time import perf_counter


@lru_cache(maxsize=None)
def polymer_formula(pairs):
    value = polymers["".join(pairs)[-2:]]
    return (value, pairs[-1])


def build_polymer(template):
    """Relatively fast solution for part 1 when the number of iterations <= 10.

    For iterations over 10 and below 20, the time grows up to 3 seconds (on my
    machine), and doubles on every new iteration:
    20 iter = 3 seconds
    21 iter = 6 seconds
    22 iter = 12 seconds

    This makes this solution not feasable for the second part of the problem
    which requires 40 iterations (that would take, on my machine, 36.41 days to
    compute).

    Args:
        template (str): The template string to compute the polymer off of.

    Returns:
        iterable: The iterable containing the polymer chain.
    """
    template = iter(template)
    for i in range(10):
        first, template = tee(template, 2)
        result = map(polymer_formula, pairwise(template))
        template = chain(next(first), chain.from_iterable(result))

    return template


def build_polymer2(template, polymers, max_iterations):
    """Faster solution for part 2, where the same algorithm for part 1 is
    needed to be evaluated, recursively, 40 times.

    Here the solution is to NOT send the resulting template string to the next
    iteration, but instead to keep the "count" of the elements between
    iterations.

    To solve this we can use the Counter object, which is pretty handy and a
    nice way to keep track of the number of the various objects.
    Only this is not going to be good enough tho, as we are going to generate
    a "count", evaluating the same pair multiple times as there is only going
    to be a limited amount of pairs found in the process.

    To solve this, we need to cache the results, and we can use lru_cache
    to achieve this, in order to speed the evaluation up quite a lot.

    Args:
        template (str): The source template
        polymers (dict): The polymers dictionary containing the rules to
            generate new polymers
        max_iterations (int): Max number of iterations for the calculation of
            the final polymer chain.

    Returns:
        Counter: The counter object containing the number of times each polymer
            is found in the polymer chain.
    """

    @lru_cache(maxsize=None)
    def recursive_counter(pair, iteration):
        """Recursive function that, given a string defining 2 letters and the
        current iteration value, will return the counter object recursively
        evaluating the new polymer generated by the rule:
            ABC (with AB->x and BC->y) => AxByC.

        Args:
            pair (str): The string defining a pair in the polymer dict.
            iteration (int): Current iteration number.

        Returns:
            [type]: [description]
        """
        if iteration == max_iterations:
            return Counter()

        value = polymers[pair]

        counter_new_element = Counter(value)
        counter_new_element.update(recursive_counter(pair[0]+value, iteration+1))
        counter_new_element.update(recursive_counter(value+pair[1], iteration+1))

        return counter_new_element

    counter = Counter(template)
    for a, b in pairwise(template):
        counter.update(recursive_counter(a+b, 0))
    return counter


if __name__ == "__main__":
    input_file = Path(__file__).parent / Path("p1_input")
    input_file_data = input_file.open().readlines()

    template = input_file_data[0].strip()
    polymers = {}
    for line in input_file_data[2:]:
        key, value = line.strip().split(" -> ")
        polymers[key] = value

    print("Part 1: 10 iterations")
    polymer_chain = build_polymer(template)
    counting_values = Counter(polymer_chain)
    low, *_, high = sorted(counting_values.values())
    print(f"H: {high} - L: {low} == {high-low}")

    print("Part 2: 40 iterations")
    result = build_polymer2(template, polymers, 40)
    low, *_, high = sorted(result.values())
    print(f"H: {high} - L: {low} == {high-low}")






